package generate

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"strings"
)

func GenerateTypeScript(inputFileSpecs []string, output io.Writer) error {

	fmt.Fprintf(output, "// Generated by github.com/exponent-io/gots\n\n")
	for _, fs := range inputFileSpecs {
		err := processFile(fs, output)
		if err != nil {
			return err
		}
	}

	return nil
}

func processFile(filename string, w io.Writer) error {

	fs := token.NewFileSet()

	astFile, err := parser.ParseFile(fs, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	//ast.Print(fs, astFile)

	ast.Walk(&StructVisitor{out: w, fileSet: fs}, astFile)

	return nil
}

type FieldSpec struct {
	fieldName string
	optional  string
	typeName  string
	jsonName  string
}

func writeFieldSpecs(w io.Writer, fields []FieldSpec) {
	var nameWidth, typeWidth int
	for _, f := range fields {
		jsonWidth := len(f.jsonName) + len(f.optional)
		if jsonWidth > nameWidth {
			nameWidth = jsonWidth
		}
		if len(f.typeName) > typeWidth {
			typeWidth = len(f.typeName)
		}
	}
	for _, f := range fields {
		fmt.Fprintf(w, "  %v%v:%v %v;%v // %v\n",
			f.jsonName, f.optional, strings.Repeat(" ", nameWidth-len(f.jsonName)-len(f.optional)),
			f.typeName, strings.Repeat(" ", typeWidth-len(f.typeName)),
			f.fieldName)
	}
}

type StructVisitor struct {
	out     io.Writer
	fileSet *token.FileSet
}

func (v *StructVisitor) Visit(node ast.Node) ast.Visitor {

	switch n := node.(type) {
	case *ast.TypeSpec:
		fmt.Fprintf(v.out, "// %v\n", v.fileSet.Position(n.Pos()))
		if n.Doc != nil {
			for _, c := range n.Doc.List {
				fmt.Fprintf(v.out, "// %v\n", c.Text)
			}
		}
		fmt.Fprintf(v.out, "export interface %v {\n", n.Name)

		fieldVisitor := &FieldVisitor{out: v.out}
		ast.Walk(fieldVisitor, n.Type)

		writeFieldSpecs(v.out, fieldVisitor.fields)

		fmt.Fprintf(v.out, "}\n\n")
		return nil
	}
	return v
}

type FieldVisitor struct {
	out io.Writer

	fields []FieldSpec
}

func (v *FieldVisitor) Visit(node ast.Node) ast.Visitor {

	switch n := node.(type) {
	case *ast.Field:
		var fld FieldSpec
		fld.fieldName = n.Names[0].Name
		fld.jsonName = fld.fieldName

		typeViz := &TypeVisitor{out: v.out}
		ast.Walk(typeViz, n.Type)
		fld.typeName = typeViz.typeName

		tag := ""
		if n.Tag != nil && len(n.Tag.Value) > 2 {
			var tagOpts tagOptions

			tag = n.Tag.Value[1 : len(n.Tag.Value)-1]
			tag = getStructTag(tag, "json")
			fld.jsonName, tagOpts = parseTag(tag)

			if fld.jsonName == "-" {
				return nil
			} else if tagOpts.Contains("omitempty") {
				fld.optional = "?"
			}
		}

		v.fields = append(v.fields, fld)
		return nil
	}
	return v
}

type TypeVisitor struct {
	out      io.Writer
	typeName string
}

func (v *TypeVisitor) Visit(node ast.Node) ast.Visitor {

	switch n := node.(type) {
	case *ast.ArrayType:
		typeViz := &TypeVisitor{out: v.out}
		ast.Walk(typeViz, n.Elt)
		v.typeName = tsType(typeViz.typeName) + "[]"
		return nil
	case *ast.Ident:
		v.typeName = tsType(n.Name)
		return nil
	}
	return v
}

func tsType(goType string) string {

	switch goType {
	case "string":
		return "string"
	case "bool":
		return "boolean"
	case "interface{}":
		return "any"
	case "int", "int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "float32", "float64":
		return "number"
	}
	return goType
}
